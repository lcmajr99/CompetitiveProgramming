
---

# ğŸ§© LeetCode 4 â€” Median of Two Sorted Arrays

**Linguagem:** C++  
**NÃ­vel:** DifÃ­cil  
**Paradigma:** Busca BinÃ¡ria, DivisÃ£o e Conquista  
**Link:** [LeetCode 4 â€” Median of Two Sorted Arrays](https://leetcode.com/problems/median-of-two-sorted-arrays/description/)  

---

## ğŸ“œ Enunciado

Dadas duas listas ordenadas `nums1` e `nums2` de tamanhos `m` e `n`, respectivamente, encontre a **mediana** das duas listas combinadas.

O algoritmo deve ter complexidade de tempo **O(log (m+n))**.

### ğŸ”¹ Exemplos

**Exemplo 1:**

```text
Input: nums1 = [1,3], nums2 = [2]
Output: 2.0
ExplicaÃ§Ã£o: A lista combinada Ã© [1,2,3] e a mediana Ã© 2.
```

**Exemplo 2:**

```text
Input: nums1 = [1,2], nums2 = [3,4]
Output: 2.5
ExplicaÃ§Ã£o: A lista combinada Ã© [1,2,3,4] e a mediana Ã© (2 + 3) / 2 = 2.5.
```

---

## ğŸ’¡ IntuiÃ§Ã£o

A ideia Ã© usar **busca binÃ¡ria** na menor das duas listas para encontrar a **partiÃ§Ã£o correta** entre os elementos da esquerda e da direita, de modo que:

```
Aleft <= Bright  &&  Bleft <= Aright
```

onde:

* `Aleft`, `Aright` sÃ£o os elementos Ã  esquerda e Ã  direita da partiÃ§Ã£o de `nums1`,
* `Bleft`, `Bright` sÃ£o os elementos Ã  esquerda e Ã  direita da partiÃ§Ã£o de `nums2`.

Com essa condiÃ§Ã£o satisfeita, a mediana pode ser calculada diretamente.

---

## ğŸ§  EstratÃ©gia

1. Sempre aplicar a busca binÃ¡ria na lista menor (`nums1`).
2. Calcular partiÃ§Ãµes `i` e `j` que dividem as duas listas de forma balanceada.
3. Verificar se a partiÃ§Ã£o Ã© vÃ¡lida:

   * Se `Aleft <= Bright` e `Bleft <= Aright`, entÃ£o encontrou a posiÃ§Ã£o da mediana.
   * Caso contrÃ¡rio:

     * Se `Aleft > Bright`, mover partiÃ§Ã£o para a esquerda.
     * Se `Bleft > Aright`, mover para a direita.
4. Retornar:

   * `(max(Aleft, Bleft) + min(Aright, Bright)) / 2` se a soma dos tamanhos for par.
   * `min(Aright, Bright)` se for Ã­mpar.

---

## ğŸ§© CÃ³digo Fonte (Busca BinÃ¡ria)

```cpp

class Solution {
   public:
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        if (nums1.size() > nums2.size())
            return findMedianSortedArrays(nums2, nums1);

        int n1 = nums1.size(), n2 = nums2.size();
        int total = n1 + n2;
        int half = total / 2;

        int left = 0, right = n1;

        while (true) {
            int i = (left + right) / 2;  // partiÃ§Ã£o em nums1
            int j = half - i;            // partiÃ§Ã£o em nums2

            int Aleft = (i > 0) ? nums1[i - 1] : INT_MIN;
            int Aright = (i < n1) ? nums1[i] : INT_MAX;
            int Bleft = (j > 0) ? nums2[j - 1] : INT_MIN;
            int Bright = (j < n2) ? nums2[j] : INT_MAX;

            if (Aleft <= Bright && Bleft <= Aright) {
                // Achou a partiÃ§Ã£o correta
                if (total % 2)
                    return min(Aright, Bright);  // Ã­mpar
                else
                    return (max(Aleft, Bleft) + min(Aright, Bright)) / 2.0;
            } else if (Aleft > Bright) {
                right = i - 1;
            } else {
                left = i + 1;
            }
        }
    }
};

```

---

## ğŸ“ CÃ³digo Anotado

* **`findMedianSortedArrays`**

  * Garante que `nums1` seja sempre o menor vetor.
  * Usa **busca binÃ¡ria** para encontrar partiÃ§Ã£o correta entre os dois vetores.
  * Calcula elementos Ã  esquerda (`Aleft`, `Bleft`) e Ã  direita (`Aright`, `Bright`) da partiÃ§Ã£o.
  * Retorna a mediana conforme o total de elementos (Ã­mpar/par).

---

## ğŸ”„ Passo a Passo da ExecuÃ§Ã£o

Exemplo:
`nums1 = [1,3]`, `nums2 = [2]`

| IteraÃ§Ã£o | i | j | Aleft | Aright | Bleft | Bright | Aleft â‰¤ Bright | Bleft â‰¤ Aright |
| -------- | - | - | ----- | ------ | ----- | ------ | -------------- | -------------- |
| 1        | 1 | 0 | 1     | 3      | -âˆ    | 2      | âœ…              | âœ…              |

**Resultado:** `min(3, 2) = 2.0`

---

## â±ï¸ AnÃ¡lise de Complexidade

| Aspecto | Complexidade      | ExplicaÃ§Ã£o                           |
| ------- | ----------------- | ------------------------------------ |
| Tempo   | O(log(min(m, n))) | Busca binÃ¡ria apenas no vetor menor. |
| EspaÃ§o  | O(1)              | Usa apenas variÃ¡veis auxiliares.     |


---

## ğŸ§ª Casos de Teste

| nums1  | nums2  | SaÃ­da Esperada |
| ------ | ------ | -------------- |
| [1, 3] | [2]    | 2.0            |
| [1, 2] | [3, 4] | 2.5            |
| [0, 0] | [0, 0] | 0.0            |
| []     | [1]    | 1.0            |
| [2]    | []     | 2.0            |

---

## ğŸš€ ObservaÃ§Ãµes Finais

* Abordagem Ã³tima, **sem necessidade de mesclar os vetores**.
* Usa apenas **busca binÃ¡ria**, garantindo eficiÃªncia mesmo em listas grandes.

---

## ğŸ“š ReferÃªncias

* [LeetCode 4 â€” Median of Two Sorted Arrays](https://leetcode.com/problems/median-of-two-sorted-arrays/description/)
* [Binary Search Median Explanation â€” GeeksForGeeks](https://www.geeksforgeeks.org/median-of-two-sorted-arrays-of-different-sizes/)

---

## âœ… Resumo Final

* SoluÃ§Ã£o eficiente usando **busca binÃ¡ria na menor lista**.
* **Tempo:** O(log(min(m, n)))
* **EspaÃ§o:** O(1)
* Calcula a mediana sem precisar combinar ou ordenar novamente os vetores.

---
